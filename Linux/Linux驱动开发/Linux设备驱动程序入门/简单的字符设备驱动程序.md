
----------

#### 简单的字符设备驱动程序 ####

2019/8/13 23 :14 :09 

Author：terrycoder

----------


#### 字符设备和块设备 ####

**字符设备驱动程序框架**

Linux系统将设备分为3中类型：字符设备、块设备和网络接口设备。

**字符设备**

是指那些只能一个字节一个字节读写数据的设备，不能随机读取设备内存中的某一数据。其读取数据需要按照先后顺序。字符设备是面向数据流的设备。常见的设备有鼠标、键盘、串口、控制台、和LED。

**块设备**

指那些可以从设备的任意位置读取一定长度数据的设备。其读取数据不必按照先后顺序，可以定位到设备的某一具体位置读取数据。常见的块设备有硬盘、磁盘、U盘、SD卡等。

**字符设备和块设备的区分**

每一个字符设备或者块设备都在/dev目录下对应一个设备文件。可以通过查看该目录下的文件属性来区分设备是字符设备还是块设备。进入/dev中使用ls -l命令就可以查看设备的属性。


**主设备号和次设备号**

一个字符设备或者块设备都有一个主设备号和次设备号。主设备号和次设备号统称为设备号。设备号用来表示一个特定的驱动程序。次设备号用来表示使用该驱动程序的各设备。

**主设备号和次设备号的表示**

在linux内核中，dev_t类型用来表示设备号。

	typedef u_long dev_t;

u_long 在32位机中是4个字节，在64位机中是8个字节。在32位机中，高12表示主设备号，低20位表示次设备号。

| 表示方法| dev_t|
| --- | --- |
|主设备号12位 | 次设备号20位 |

**主设备号和次设备号的获取**

可以使用MAJOR宏得到主设备号，使用MINOR宏得到次设备号。

	#define MINORBITS 20					//次设备号位数
	#define MINORMASK ((1U <<MINORBITS)-1)  // 次设备号掩码
	#define MAJOR(dev) ((unsigned int) ((dev) >> MINORBITS)) //dev右移20位得到主设备号
	
	#define MINOR(dev) ((unsigned int) ((dev) & MINORMASK)) //与次设备号掩码与，得到次设备号
	#define MKDEV(ma,mi) ((ma) << MINORBITS |(mi)) //将主设备号和次设备号转换为设备号类型

**设备号动态分配和静态分配**

静态设备号就是驱动开发者，静态指定一个设备号。可能会造成设备号冲突，影响使用。建议使用动态分配设备号的方法。

动态分配设备号的函数是alloc\_chrdev\_region()。

在构建字符设备之前，首先要向系统申请一个或者多个设备号,完成该工作的函数是register\_chrdev\_region。该函数在<fs/char\_dev.c>中定义。

	int register_chrdev_region(dev_t from, unsigned count,const char* name);

其中，from的是要分配的设备号范围的起始值，一般只提供from的主设备号，from的次设备号通常被设置成0。count是需要申请的连续设备号的个数。name和该范围变好关联的设备名称，该名称不能超过64字节。

register_chrdev_region()函数成功时返回0，错误时，返回一个负的错误码，并且不能为字符设备分配设备号。

可以使用alloc\_chrdev\_region()函数动态申请一个设备号。

	int alloc_chrdev_region(dev_t *dev,unsigned baseminor,unsigned count,const char *name)

dev作为输出函数，在函数成功返回后将保存已经分配的设备号。函数有可能申请一段连续的设备号，这是dev返回的第一个设备号。baseminor表示要申请的第一个次设备号，通常设为0，count和name与register\_chrdev\_region()函数的对应参数一样，count表示要申请的连续设备号个数，name表示设备名字。

**释放设备号**

使用上面两种方式申请的设备号，都应该在不使用设备时，释放设备号，设备号的释放使用以下函数：

	void unregister_chrdev_region(dev_t from,unsigned count);

from表示要释放的设备号，count表示从from开始要释放的设备号个数。通常在模块卸载函数中调用unregister\_chrdev\_region()函数。